<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D ë‹¬ë ¥ ë³´ë“œê²Œì„ (í†µí•©í˜•)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* í•˜ëŠ˜ìƒ‰ ë°°ê²½ */
      font-family: 'Arial', sans-serif;
    }
    #rollButton {
      position: absolute;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 12px 20px;
      font-size: 16px;
      background: #0f3460; color: #fff;
      border: none; border-radius: 5px;
      cursor: pointer; transition: 0.3s;
    }
    #rollButton:hover {
      background: #00c3ff;
    }
    canvas {
      display: block;
      position: fixed; /* í™”ë©´ì— ê³ ì • */
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1; /* ë²„íŠ¼ë³´ë‹¤ ë’¤ */
    }
  </style>
</head>
<body>
  <!-- ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸° ë²„íŠ¼ -->
  <button id="rollButton">ğŸ² ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°</button>

  <!-- Three.js & TWEEN.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

  <script>
    let scene, camera, renderer;
    let tiles = [];          // 31ì¹¸ ë‹¬ë ¥(3D ë³´ë“œ)
    let boat;                // ë°°(ì—¬ê°ì„ ) ëª¨ë¸
    let boatIndex = 0;       // í˜„ì¬ ë°°ê°€ ìœ„ì¹˜í•œ íƒ€ì¼ ì¸ë±ìŠ¤
    let waveTime = 0;        // ë¬¼ê²° íš¨ê³¼ìš© ì‹œê°„

    const ROWS = 5;          // ë‹¬ë ¥ 5ì£¼ (ìµœëŒ€ 31ì¼ê¹Œì§€ ê°€ì •)
    const COLS = 7;          // í•œ ì£¼ì— 7ì¼ (ì¼~í† )
    const DAYS = 31;         // ë‹¬ë ¥ ì¼ìˆ˜
    const TILE_SIZE = 4;     // ê° íƒ€ì¼ ê°„ ê°„ê²© (3D ê³µê°„ìƒ)

    // ì´ˆê¸°í™”
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // í•˜ëŠ˜ìƒ‰

      // ì¹´ë©”ë¼
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.set(0, 25, 28);
      camera.lookAt(0, 0, 0);

      // ë Œë”ëŸ¬
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // ì¡°ëª…
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // ë‹¬ë ¥ ë³´ë“œ ìƒì„±
      createCalendarBoard();

      // ë°°(ì—¬ê°ì„ ) ìƒì„±
      createBoat();

      // ì´ë²¤íŠ¸
      window.addEventListener('resize', onWindowResize);
      document.getElementById('rollButton').addEventListener('click', rollDice);

      // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
      animate();
    }

    // 3D ë‹¬ë ¥ ë³´ë“œ ìƒì„± (31ì¹¸)
    function createCalendarBoard() {
      const dayNames = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];

      let dayCount = 1;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (dayCount > DAYS) break;

          // ë°”ë‹¥ íƒ€ì¼ (BoxGeometry)
          const tileGeo = new THREE.BoxGeometry(3.5, 0.5, 3.5);
          let tileColor = 0xffffff;
          if (col === 0) tileColor = 0xff5757;   // ì¼ìš”ì¼(ë¹¨ê°„ìƒ‰)
          if (col === 6) tileColor = 0x579eff;   // í† ìš”ì¼(íŒŒë€ìƒ‰)

          const tileMat = new THREE.MeshStandardMaterial({ color: tileColor });
          const tileMesh = new THREE.Mesh(tileGeo, tileMat);

          // 3D ê³µê°„ì—ì„œì˜ ìœ„ì¹˜ ê³„ì‚°
          // (col - 3) * TILE_SIZE => ì¤‘ì•™ì •ë ¬
          // (row - 2) * TILE_SIZE => ì¤‘ì•™ì •ë ¬
          const xPos = (col - 3) * TILE_SIZE;
          const zPos = - (row - 2) * TILE_SIZE;
          tileMesh.position.set(xPos, 0, zPos);

          scene.add(tileMesh);
          tiles.push({
            mesh: tileMesh,
            dayNumber: dayCount,
            dayName: dayNames[col]  // ìš”ì¼ ì´ë¦„
          });

          dayCount++;
        }
      }
    }

    // ì—¬ê°ì„  ëª¨ì–‘ ë°° ìƒì„±
    function createBoat() {
      const group = new THREE.Group();

      // 1) íŒŒë€ìƒ‰ ì„ ì²´ (ë‘¥ê·¼ ë³´íŠ¸ í•˜ë‹¨)
      const hullGeo = new THREE.CylinderGeometry(2, 2.5, 5, 16);
      const hullMat = new THREE.MeshStandardMaterial({ color: 0x0077ff });
      const hull = new THREE.Mesh(hullGeo, hullMat);
      hull.rotation.z = Math.PI / 2;
      group.add(hull);

      // 2) ì˜¤ë Œì§€ìƒ‰ í…Œë‘ë¦¬ (ë°° ìœ—ë¶€ë¶„)
      const rimGeo = new THREE.TorusGeometry(2.5, 0.2, 8, 16);
      const rimMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.rotation.x = Math.PI / 2;
      group.add(rim);

      // 3) ë…¸ë€ìƒ‰ ìƒì¸µë¶€ (ê°ì‹¤)
      const cabinGeo = new THREE.BoxGeometry(2.5, 1.8, 2);
      const cabinMat = new THREE.MeshStandardMaterial({ color: 0xffdd00 });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(0, 2.5, 0);
      group.add(cabin);

      // 4) í°ìƒ‰ ì°½ë¬¸ë“¤
      const windowGeo = new THREE.CircleGeometry(0.3, 16);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      for (let i = -0.7; i <= 0.7; i += 0.7) {
        const wMesh = new THREE.Mesh(windowGeo, windowMat);
        wMesh.rotation.y = Math.PI / 2;
        wMesh.position.set(1.5, 2.5, i);
        group.add(wMesh);
      }

      // 5) ë›ëŒ€ + ì¤„ (ê°„ë‹¨íˆ í‘œí˜„)
      // ë›ëŒ€(í´)
      const mastGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      const mastMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      const mast = new THREE.Mesh(mastGeo, mastMat);
      mast.position.set(0, 4, 0);
      group.add(mast);

      // ì¤„ (ì–‘ìª½ ê¸°ë‘¥ì— ì—°ê²°ëœ ëŠë‚Œ)
      const lineGeo = new THREE.CylinderGeometry(0.03, 0.03, 3.2, 4);
      const lineMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      // ì™¼ìª½ ì¤„
      const lineLeft = new THREE.Mesh(lineGeo, lineMat);
      lineLeft.position.set(-1, 2.5, 0);
      lineLeft.rotation.z = 0.5; // ê¸°ìš¸ì´ê¸°
      group.add(lineLeft);
      // ì˜¤ë¥¸ìª½ ì¤„
      const lineRight = new THREE.Mesh(lineGeo, lineMat);
      lineRight.position.set(1, 2.5, 0);
      lineRight.rotation.z = -0.5;
      group.add(lineRight);

      // ì´ˆê¸° ìœ„ì¹˜ (tiles[0] ìœ„)
      boat = group;
      scene.add(boat);
      updateBoatPosition();
    }

    // ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°
    function rollDice() {
      const diceValue = Math.floor(Math.random() * 6) + 1;
      // ë°°ê°€ ì´ë™í•  íƒ€ì¼ ì¸ë±ìŠ¤ ê³„ì‚°
      boatIndex = Math.min(boatIndex + diceValue, tiles.length - 1);
      updateBoatPosition();
    }

    // ë°° ìœ„ì¹˜ ê°±ì‹  (TWEEN ì• ë‹ˆë©”ì´ì…˜)
    function updateBoatPosition() {
      if (boatIndex < tiles.length) {
        const targetMesh = tiles[boatIndex].mesh;
        const targetPos = targetMesh.position.clone();
        targetPos.y = 1; // íƒ€ì¼ ìœ„ë¡œ ì¡°ê¸ˆ ë„ìš°ê¸°

        // ë¶€ë“œëŸ½ê²Œ ì´ë™
        new TWEEN.Tween(boat.position)
          .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
          .easing(TWEEN.Easing.Sinusoidal.InOut)
          .start();
      }
    }

    // í”„ë ˆì„ ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);
      waveTime += 0.02;

      // ë¬¼ê²° íš¨ê³¼ (ì‚´ì§ í”ë“¤ë¦¼)
      if (boat) {
        boat.rotation.x = Math.sin(waveTime) * 0.05;
        boat.rotation.z = Math.sin(waveTime * 1.5) * 0.05;
      }

      TWEEN.update();
      renderer.render(scene, camera);
    }

    // í™”ë©´ í¬ê¸° ë³€í™” ëŒ€ì‘
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ì‹œì‘
    init();
  </script>
</body>
</html>