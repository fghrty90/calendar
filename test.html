<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D 달력 보드게임 (큰 보드, 뾰족한 배, 미니맵)</title>
  <style>
    body {
      margin: 0; overflow: hidden;
      background: #87ceeb; /* 하늘색 배경 */
      font-family: 'Arial', sans-serif;
    }
    /* 상단 UI */
    #ui-container {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; gap: 10px;
      z-index: 10;
    }
    button {
      background: #0f3460; color: #fff; border: none;
      padding: 10px 15px; font-size: 16px; cursor: pointer;
      border-radius: 5px; transition: 0.3s;
    }
    button:hover { background: #00c3ff; }
    /* Three.js 전체화면 (두 개의 뷰포트로 사용) */
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- 상단 버튼들 -->
  <div id="ui-container">
    <button onclick="addPlayer()">플레이어 추가</button>
    <button onclick="removePlayer()">플레이어 삭제</button>
    <button onclick="rollDice()">주사위 굴리기</button>
  </div>

  <!-- Three.js & TWEEN.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

  <script>
    /********************************************************
     * 전역 변수 및 기본 설정
     ********************************************************/
    let scene, renderer;
    let mainCamera, miniMapCamera;
    let boardGroup;          // 보드 전체(타일 모음)를 그룹으로
    let tiles = [];          // 개별 타일 Mesh
    let players = [];        // 여러 플레이어(배) 객체
    let playerPositions = [];  
    let currentPlayerIndex = 0;
    let waveTime = 0;

    const ROWS = 5;          // 달력 5주 (최대 31일)
    const COLS = 7;          // 일~토 7일
    const DAYS = 31;         // 최대 31일
    const TILE_SIZE = 8;     // 각 타일 간 간격 (더 크게)
    const MAX_PLAYERS = 4;

    // 타일 색상 구간 (예시)
    const tileRegions = [
      0xffdddd, // 1~10
      0xddffdd, // 11~20
      0xddddff  // 21~31
    ];

    // 플레이어별 뾰족한 배 색상
    const playerColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];

    /********************************************************
     * 초기화
     ********************************************************/
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      // 메인 카메라
      mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      mainCamera.position.set(0, 100, 100);
      mainCamera.lookAt(0, 0, 0);

      // 미니맵 카메라 (Top-Down 시점)
      miniMapCamera = new THREE.OrthographicCamera(-100, 100, 50, -50, 1, 1000);
      miniMapCamera.position.set(0, 300, 0);
      miniMapCamera.lookAt(0, 0, 0);

      // 렌더러
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 조명
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(100, 200, 100);
      scene.add(dirLight);

      // 보드 그룹 생성
      boardGroup = new THREE.Group();
      scene.add(boardGroup);

      // 보드 생성
      createCalendarBoard();

      // 보드 전체 크기를 바탕으로 카메라 자동 조정
      fitCameraToBoard();

      // 이벤트
      window.addEventListener('resize', onWindowResize);
      animate();
    }

    /********************************************************
     * 보드 생성 (31칸 달력)
     ********************************************************/
    function createCalendarBoard() {
      let dayCount = 1;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (dayCount > DAYS) break;

          // 구간별 색상
          let regionColor;
          if (dayCount <= 10) regionColor = tileRegions[0];
          else if (dayCount <= 20) regionColor = tileRegions[1];
          else regionColor = tileRegions[2];

          // 큼직한 타일
          const tileGeo = new THREE.BoxGeometry(6, 0.5, 6);
          const tileMat = new THREE.MeshStandardMaterial({ color: regionColor });
          const tile = new THREE.Mesh(tileGeo, tileMat);

          // 위치 (중앙 정렬)
          const xPos = (col - 3) * TILE_SIZE;
          const zPos = -(row - 2) * TILE_SIZE;
          tile.position.set(xPos, 0, zPos);

          boardGroup.add(tile);
          tiles.push(tile);

          dayCount++;
        }
      }
    }

    /********************************************************
     * 보드 전체를 감싸는 박스를 구해 카메라 세팅
     ********************************************************/
    function fitCameraToBoard() {
      const boundingBox = new THREE.Box3().setFromObject(boardGroup);
      const size = boundingBox.getSize(new THREE.Vector3());
      const center = boundingBox.getCenter(new THREE.Vector3());

      // 메인 카메라를 보드 전체가 화면에 들어오도록 조정
      const maxDim = Math.max(size.x, size.y, size.z);
      // 카메라 FOV → 라디안 변환
      const fov = mainCamera.fov * (Math.PI / 180);
      // 보드를 모두 담기 위해 필요한 거리 계산
      let cameraDist = maxDim / (2 * Math.tan(fov / 2));
      cameraDist *= 1.3; // 여유 공간

      // 카메라 위치 설정
      mainCamera.position.set(center.x, cameraDist, center.z + cameraDist);
      mainCamera.lookAt(center);
    }

    /********************************************************
     * 뾰족한 배 생성 (Cone + Cylinder)
     ********************************************************/
    function createBoat(playerIndex) {
      const color = playerColors[playerIndex % playerColors.length];

      const group = new THREE.Group();
      group.scale.set(1.2, 1.2, 1.2); // 크기 조정

      // 앞부분 (Cone) → 뾰족
      const frontGeo = new THREE.ConeGeometry(2, 4, 16);
      const frontMat = new THREE.MeshStandardMaterial({ color });
      const front = new THREE.Mesh(frontGeo, frontMat);
      front.rotation.x = Math.PI / 2;
      front.position.set(0, 0, 2);
      group.add(front);

      // 뒷부분 (Cylinder)
      const backGeo = new THREE.CylinderGeometry(2, 2, 4, 16);
      const backMat = new THREE.MeshStandardMaterial({ color });
      const back = new THREE.Mesh(backGeo, backMat);
      back.rotation.x = Math.PI / 2;
      back.position.set(0, 0, -0.1);
      group.add(back);

      // 오렌지 테두리
      const rimGeo = new THREE.TorusGeometry(2, 0.15, 8, 16);
      const rimMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.z = -0.1;
      group.add(rim);

      // 노란 객실
      const cabinGeo = new THREE.BoxGeometry(2.5, 1.2, 1.8);
      const cabinMat = new THREE.MeshStandardMaterial({ color: 0xffdd00 });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(0, 1.8, -0.5);
      group.add(cabin);

      // 흰색 창문
      const windowGeo = new THREE.CircleGeometry(0.3, 8);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      for (let i = -0.3; i <= 0.3; i += 0.3) {
        const wMesh = new THREE.Mesh(windowGeo, windowMat);
        wMesh.rotation.y = Math.PI / 2;
        wMesh.position.set(2, 1.8, i - 0.5);
        group.add(wMesh);
      }

      // 시작 위치 (타일[0] 위)
      if (tiles[0]) {
        group.position.set(tiles[0].position.x, 1, tiles[0].position.z);
      }

      return group;
    }

    /********************************************************
     * 플레이어 추가/삭제
     ********************************************************/
    function addPlayer() {
      if (players.length >= MAX_PLAYERS) {
        alert("최대 4명까지 가능!");
        return;
      }
      const newBoat = createBoat(players.length);
      scene.add(newBoat);
      players.push(newBoat);
      playerPositions.push(0);
      currentPlayerIndex = 0;
    }

    function removePlayer() {
      if (players.length === 0) return;
      const removedBoat = players.pop();
      scene.remove(removedBoat);
      playerPositions.pop();
      currentPlayerIndex = 0;
    }

    /********************************************************
     * 주사위 굴리기
     ********************************************************/
    function rollDice() {
      if (players.length === 0) {
        alert("플레이어가 없습니다!");
        return;
      }
      const diceValue = Math.floor(Math.random() * 6) + 1;
      const idx = currentPlayerIndex;
      playerPositions[idx] = Math.min(playerPositions[idx] + diceValue, tiles.length - 1);
      moveBoat(idx);

      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
    }

    function moveBoat(idx) {
      const targetTile = tiles[playerPositions[idx]];
      const targetPos = targetTile.position.clone();
      targetPos.y = 1;
      new TWEEN.Tween(players[idx].position)
        .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1200)
        .easing(TWEEN.Easing.Sinusoidal.InOut)
        .start();
    }

    /********************************************************
     * 메인 루프
     ********************************************************/
    function animate() {
      requestAnimationFrame(animate);

      waveTime += 0.02;
      players.forEach((boat, i) => {
        boat.rotation.x = Math.sin(waveTime + i) * 0.03;
        boat.rotation.z = Math.sin(waveTime * 1.5 + i) * 0.03;
      });

      TWEEN.update();
      renderViews();
    }

    /********************************************************
     * 2개 카메라 뷰: 메인 전체화면 + 미니맵(오른쪽 상단)
     ********************************************************/
    function renderViews() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      // 1) 메인 카메라 (화면 전체)
      renderer.setViewport(0, 0, w, h);
      renderer.setScissor(0, 0, w, h);
      renderer.setScissorTest(true);
      renderer.render(scene, mainCamera);

      // 2) 미니맵 (오른쪽 상단 1/4)
      const miniW = w / 4;
      const miniH = h / 4;
      renderer.setViewport(w - miniW - 10, h - miniH - 10, miniW, miniH);
      renderer.setScissor(w - miniW - 10, h - miniH - 10, miniW, miniH);
      renderer.setScissorTest(true);
      miniMapCamera.lookAt(0, 0, 0);
      renderer.render(scene, miniMapCamera);
    }

    /********************************************************
     * 화면 크기 대응
     ********************************************************/
    function onWindowResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);

      mainCamera.aspect = window.innerWidth / window.innerHeight;
      mainCamera.updateProjectionMatrix();
    }

    // 시작
    init();
  </script>
</body>
</html>