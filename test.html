<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D 달력 보드게임 (통합형)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* 하늘색 배경 */
      font-family: 'Arial', sans-serif;
    }
    #rollButton {
      position: absolute;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 12px 20px;
      font-size: 16px;
      background: #0f3460; color: #fff;
      border: none; border-radius: 5px;
      cursor: pointer; transition: 0.3s;
    }
    #rollButton:hover {
      background: #00c3ff;
    }
    canvas {
      display: block;
      position: fixed; /* 화면에 고정 */
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1; /* 버튼보다 뒤 */
    }
  </style>
</head>
<body>
  <!-- 주사위 굴리기 버튼 -->
  <button id="rollButton">🎲 주사위 굴리기</button>

  <!-- Three.js & TWEEN.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

  <script>
    let scene, camera, renderer;
    let tiles = [];          // 31칸 달력(3D 보드)
    let boat;                // 배(여객선) 모델
    let boatIndex = 0;       // 현재 배가 위치한 타일 인덱스
    let waveTime = 0;        // 물결 효과용 시간

    const ROWS = 5;          // 달력 5주 (최대 31일까지 가정)
    const COLS = 7;          // 한 주에 7일 (일~토)
    const DAYS = 31;         // 달력 일수
    const TILE_SIZE = 4;     // 각 타일 간 간격 (3D 공간상)

    // 초기화
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // 하늘색

      // 카메라
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.set(0, 25, 28);
      camera.lookAt(0, 0, 0);

      // 렌더러
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 조명
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // 달력 보드 생성
      createCalendarBoard();

      // 배(여객선) 생성
      createBoat();

      // 이벤트
      window.addEventListener('resize', onWindowResize);
      document.getElementById('rollButton').addEventListener('click', rollDice);

      // 애니메이션 시작
      animate();
    }

    // 3D 달력 보드 생성 (31칸)
    function createCalendarBoard() {
      const dayNames = ["일", "월", "화", "수", "목", "금", "토"];

      let dayCount = 1;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (dayCount > DAYS) break;

          // 바닥 타일 (BoxGeometry)
          const tileGeo = new THREE.BoxGeometry(3.5, 0.5, 3.5);
          let tileColor = 0xffffff;
          if (col === 0) tileColor = 0xff5757;   // 일요일(빨간색)
          if (col === 6) tileColor = 0x579eff;   // 토요일(파란색)

          const tileMat = new THREE.MeshStandardMaterial({ color: tileColor });
          const tileMesh = new THREE.Mesh(tileGeo, tileMat);

          // 3D 공간에서의 위치 계산
          // (col - 3) * TILE_SIZE => 중앙정렬
          // (row - 2) * TILE_SIZE => 중앙정렬
          const xPos = (col - 3) * TILE_SIZE;
          const zPos = - (row - 2) * TILE_SIZE;
          tileMesh.position.set(xPos, 0, zPos);

          scene.add(tileMesh);
          tiles.push({
            mesh: tileMesh,
            dayNumber: dayCount,
            dayName: dayNames[col]  // 요일 이름
          });

          dayCount++;
        }
      }
    }

    // 여객선 모양 배 생성
    function createBoat() {
      const group = new THREE.Group();

      // 1) 파란색 선체 (둥근 보트 하단)
      const hullGeo = new THREE.CylinderGeometry(2, 2.5, 5, 16);
      const hullMat = new THREE.MeshStandardMaterial({ color: 0x0077ff });
      const hull = new THREE.Mesh(hullGeo, hullMat);
      hull.rotation.z = Math.PI / 2;
      group.add(hull);

      // 2) 오렌지색 테두리 (배 윗부분)
      const rimGeo = new THREE.TorusGeometry(2.5, 0.2, 8, 16);
      const rimMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.rotation.x = Math.PI / 2;
      group.add(rim);

      // 3) 노란색 상층부 (객실)
      const cabinGeo = new THREE.BoxGeometry(2.5, 1.8, 2);
      const cabinMat = new THREE.MeshStandardMaterial({ color: 0xffdd00 });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(0, 2.5, 0);
      group.add(cabin);

      // 4) 흰색 창문들
      const windowGeo = new THREE.CircleGeometry(0.3, 16);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      for (let i = -0.7; i <= 0.7; i += 0.7) {
        const wMesh = new THREE.Mesh(windowGeo, windowMat);
        wMesh.rotation.y = Math.PI / 2;
        wMesh.position.set(1.5, 2.5, i);
        group.add(wMesh);
      }

      // 5) 돛대 + 줄 (간단히 표현)
      // 돛대(폴)
      const mastGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      const mastMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      const mast = new THREE.Mesh(mastGeo, mastMat);
      mast.position.set(0, 4, 0);
      group.add(mast);

      // 줄 (양쪽 기둥에 연결된 느낌)
      const lineGeo = new THREE.CylinderGeometry(0.03, 0.03, 3.2, 4);
      const lineMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      // 왼쪽 줄
      const lineLeft = new THREE.Mesh(lineGeo, lineMat);
      lineLeft.position.set(-1, 2.5, 0);
      lineLeft.rotation.z = 0.5; // 기울이기
      group.add(lineLeft);
      // 오른쪽 줄
      const lineRight = new THREE.Mesh(lineGeo, lineMat);
      lineRight.position.set(1, 2.5, 0);
      lineRight.rotation.z = -0.5;
      group.add(lineRight);

      // 초기 위치 (tiles[0] 위)
      boat = group;
      scene.add(boat);
      updateBoatPosition();
    }

    // 주사위 굴리기
    function rollDice() {
      const diceValue = Math.floor(Math.random() * 6) + 1;
      // 배가 이동할 타일 인덱스 계산
      boatIndex = Math.min(boatIndex + diceValue, tiles.length - 1);
      updateBoatPosition();
    }

    // 배 위치 갱신 (TWEEN 애니메이션)
    function updateBoatPosition() {
      if (boatIndex < tiles.length) {
        const targetMesh = tiles[boatIndex].mesh;
        const targetPos = targetMesh.position.clone();
        targetPos.y = 1; // 타일 위로 조금 띄우기

        // 부드럽게 이동
        new TWEEN.Tween(boat.position)
          .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
          .easing(TWEEN.Easing.Sinusoidal.InOut)
          .start();
      }
    }

    // 프레임 루프
    function animate() {
      requestAnimationFrame(animate);
      waveTime += 0.02;

      // 물결 효과 (살짝 흔들림)
      if (boat) {
        boat.rotation.x = Math.sin(waveTime) * 0.05;
        boat.rotation.z = Math.sin(waveTime * 1.5) * 0.05;
      }

      TWEEN.update();
      renderer.render(scene, camera);
    }

    // 화면 크기 변화 대응
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // 시작
    init();
  </script>
</body>
</html>