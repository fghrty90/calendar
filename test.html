<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D 달력 보드게임 (멀티플레이, 미니맵)</title>
  <style>
    body {
      margin: 0; 
      overflow: hidden;
      background: #87ceeb; /* 하늘색 배경 */
      font-family: 'Arial', sans-serif;
    }
    /* 상단 UI 컨테이너 */
    #ui-container {
      position: absolute;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; gap: 10px;
      z-index: 10;
    }
    button {
      background: #0f3460; color: #fff; border: none;
      padding: 10px 15px; font-size: 16px; cursor: pointer;
      border-radius: 5px; transition: 0.3s;
    }
    button:hover { background: #00c3ff; }
    /* Three.js 전체 화면 */
    canvas {
      display: block;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- 상단 버튼들 (플레이어 추가/삭제, 주사위 굴리기) -->
  <div id="ui-container">
    <button onclick="addPlayer()">플레이어 추가</button>
    <button onclick="removePlayer()">플레이어 삭제</button>
    <button onclick="rollDice()">주사위 굴리기</button>
  </div>

  <!-- Three.js & TWEEN.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

  <script>
    /* 전역 변수 */
    let scene, camera, renderer, mapCamera;       // 메인 카메라, 미니맵 카메라
    let tiles = [];                               // 3D 달력 칸(31칸)
    let players = [];                             // 여러 플레이어(배) 오브젝트
    let playerPositions = [];                     // 각 플레이어의 보드 인덱스
    let currentPlayerIndex = 0;                   // 현재 턴인 플레이어
    let waveTime = 0;                            // 물결 효과
    const ROWS = 5;                               // 달력 5주 (최대 31일까지)
    const COLS = 7;                               // 한 주 7일 (일~토)
    const DAYS = 31;                              // 최대 31일
    const TILE_SIZE = 5;                          // 각 칸 간격 (보드 크게)
    const MAX_PLAYERS = 6;                        // 최대 플레이어 수 (원하면 늘릴 수 있음)

    // 플레이어별 색상 세트 (배마다 다르게)
    const playerColorSets = [
      { hull: 0x0077ff, rim: 0xff6600, cabin: 0xffdd00 },
      { hull: 0xff5577, rim: 0x444444, cabin: 0xffff00 },
      { hull: 0x00ff88, rim: 0x5500ff, cabin: 0xffee00 },
      { hull: 0xff5500, rim: 0xeeeeee, cabin: 0x0000ff },
      { hull: 0x2222ff, rim: 0xff22ff, cabin: 0xffffff },
      { hull: 0x999999, rim: 0x333333, cabin: 0xffee33 },
    ];

    /* 초기화 */
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // 하늘색 배경

      // 메인 카메라 (플레이어 따라감)
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 30, 30);
      camera.lookAt(0, 0, 0);

      // 미니맵 카메라 (오른쪽 위, 전체 보드)
      mapCamera = new THREE.OrthographicCamera(-60, 60, 40, -40, 0.1, 200);
      mapCamera.position.set(0, 100, 0); // 위에서 내려다보기
      mapCamera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 조명
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(20, 30, 20);
      scene.add(dirLight);

      // 3D 달력 보드 생성
      createCalendarBoard();

      // 리스너
      window.addEventListener('resize', onWindowResize);

      // 애니메이션 시작
      animate();
    }

    /* 3D 달력 보드 (31칸) 생성 */
    function createCalendarBoard() {
      const dayNames = ["일", "월", "화", "수", "목", "금", "토"];
      let dayCount = 1;

      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (dayCount > DAYS) break;

          // 타일 (BoxGeometry)
          const tileGeo = new THREE.BoxGeometry(4, 0.5, 4);
          let tileColor = 0xffffff;
          if (col === 0) tileColor = 0xff5757;  // 일요일 빨강
          if (col === 6) tileColor = 0x579eff;  // 토요일 파랑
          const tileMat = new THREE.MeshStandardMaterial({ color: tileColor });
          const tileMesh = new THREE.Mesh(tileGeo, tileMat);

          // 위치 계산 (가운데 정렬)
          const xPos = (col - 3) * TILE_SIZE;
          const zPos = -(row - 2) * TILE_SIZE;
          tileMesh.position.set(xPos, 0, zPos);

          // 날짜 텍스트(3D) 추가 (원하면 텍스처로도 가능)
          const dateText = make3DText(dayCount + "일\n" + dayNames[col], col);
          dateText.position.set(xPos, 0.75, zPos);
          scene.add(dateText);

          scene.add(tileMesh);
          tiles.push({ mesh: tileMesh, index: dayCount });
          dayCount++;
        }
      }
    }

    /* 3D 텍스트 생성 (날짜+요일) */
    function make3DText(text, colIndex) {
      // 간단히 Sprite로 대체 (Three.js TextGeometry는 폰트 로드 필요)
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');

      // 바탕 투명
      ctx.clearRect(0, 0, 256, 128);
      ctx.fillStyle = (colIndex === 0 || colIndex === 6) ? '#ffffff' : '#000000';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // 여러 줄
      const lines = text.split('\n');
      lines.forEach((line, i) => {
        ctx.fillText(line, 128, 40 + i * 40);
      });

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMat);
      sprite.scale.set(2.5, 1.2, 1);
      return sprite;
    }

    /* 플레이어(배) 추가 */
    function addPlayer() {
      if (players.length >= MAX_PLAYERS) {
        alert("플레이어가 너무 많습니다!");
        return;
      }
      const colorSet = playerColorSets[players.length % playerColorSets.length];
      const newBoat = createBoat(colorSet);
      scene.add(newBoat);
      players.push(newBoat);
      playerPositions.push(0);
      focusOnPlayer(players.length - 1);
    }

    /* 플레이어(배) 삭제 */
    function removePlayer() {
      if (players.length === 0) return;
      const lastBoat = players.pop();
      scene.remove(lastBoat);
      playerPositions.pop();
      currentPlayerIndex = 0;
    }

    /* 주사위 굴리기 */
    function rollDice() {
      if (players.length === 0) {
        alert("플레이어가 없습니다!");
        return;
      }
      const diceValue = Math.floor(Math.random() * 6) + 1;
      playerPositions[currentPlayerIndex] = Math.min(
        playerPositions[currentPlayerIndex] + diceValue,
        tiles.length - 1
      );
      moveBoat(currentPlayerIndex);

      // 다음 플레이어로 턴 이동
      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      focusOnPlayer(currentPlayerIndex);
    }

    /* 특정 플레이어(배) 위치로 카메라 이동 (플레이어 위주) */
    function focusOnPlayer(pIndex) {
      const boatObj = players[pIndex];
      if (!boatObj) return;
      new TWEEN.Tween(camera.position)
        .to({
          x: boatObj.position.x,
          y: 30,
          z: boatObj.position.z + 30
        }, 1200)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();
    }

    /* 플레이어(배) 이동 (TWEEN) */
    function moveBoat(pIndex) {
      const targetIndex = playerPositions[pIndex];
      const targetPos = tiles[targetIndex].mesh.position.clone();
      targetPos.y = 1; // 타일 위로 조금 띄우기

      new TWEEN.Tween(players[pIndex].position)
        .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
        .easing(TWEEN.Easing.Sinusoidal.InOut)
        .start();
    }

    /* 여객선 모양의 배 생성 (앞부분 뾰족, 크기 축소) */
    function createBoat(colors) {
      const group = new THREE.Group();

      // 1) 앞부분 뾰족 (ConeGeometry)
      const frontConeGeo = new THREE.ConeGeometry(1.2, 2, 16);
      const frontConeMat = new THREE.MeshStandardMaterial({ color: colors.hull });
      const frontCone = new THREE.Mesh(frontConeGeo, frontConeMat);
      frontCone.rotation.z = Math.PI / 2;
      frontCone.position.set(-1.6, 0, 0); // 본체 왼쪽으로
      group.add(frontCone);

      // 2) 뒤쪽 원통 (Cylinder)
      const hullGeo = new THREE.CylinderGeometry(1.2, 1.2, 3, 16);
      const hullMat = new THREE.MeshStandardMaterial({ color: colors.hull });
      const hull = new THREE.Mesh(hullGeo, hullMat);
      hull.rotation.z = Math.PI / 2;
      hull.position.set(0.5, 0, 0);
      group.add(hull);

      // 3) 윗 테두리(오렌지색 Rim)
      const rimGeo = new THREE.TorusGeometry(1.3, 0.1, 8, 16);
      const rimMat = new THREE.MeshStandardMaterial({ color: colors.rim });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.set(0.5, 0.7, 0);
      group.add(rim);

      // 4) 노란색 상층부 (객실)
      const cabinGeo = new THREE.BoxGeometry(1.5, 1, 1.2);
      const cabinMat = new THREE.MeshStandardMaterial({ color: colors.cabin });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(0, 1.2, 0);
      group.add(cabin);

      // 5) 창문 (흰색 원형)
      const windowGeo = new THREE.CircleGeometry(0.15, 8);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const wLeft = new THREE.Mesh(windowGeo, windowMat);
      wLeft.rotation.y = Math.PI / 2;
      wLeft.position.set(0.9, 1.2, -0.2);
      group.add(wLeft);

      const wRight = new THREE.Mesh(windowGeo, windowMat);
      wRight.rotation.y = Math.PI / 2;
      wRight.position.set(0.9, 1.2, 0.2);
      group.add(wRight);

      // 6) 돛대 (간단히)
      const mastGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.8, 8);
      const mastMat = new THREE.MeshStandardMaterial({ color: colors.rim });
      const mast = new THREE.Mesh(mastGeo, mastMat);
      mast.position.set(-0.5, 1.8, 0);
      group.add(mast);

      // 스케일 조금 더 줄이기
      group.scale.set(1.2, 1.2, 1.2);

      // 초기 위치
      group.position.set(tiles[0].mesh.position.x, 1, tiles[0].mesh.position.z);

      return group;
    }

    /* 매 프레임마다 실행 (물결 효과, 카메라2) */
    function animate() {
      requestAnimationFrame(animate);
      waveTime += 0.02;

      // 모든 배를 물결에 따라 흔들리게
      players.forEach((boat, i) => {
        boat.rotation.x = Math.sin(waveTime + i) * 0.05;
        boat.rotation.z = Math.sin(waveTime * 1.5 + i) * 0.05;
      });

      TWEEN.update();

      // 메인 카메라 렌더
      renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
      renderer.clear();
      renderer.render(scene, camera);

      // 오른쪽 위 미니맵 (오버헤드 시점)
      const mapWidth = window.innerWidth / 4;  // 전체 폭의 1/4
      const mapHeight = window.innerHeight / 4; // 전체 높이의 1/4
      renderer.setViewport(window.innerWidth - mapWidth - 10, 10, mapWidth, mapHeight);
      renderer.render(scene, mapCamera);
    }

    /* 창 크기 변화 대응 */
    function onWindowResize() {
      // 메인 카메라
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      // 미니맵 카메라 (오르쏘)
      mapCamera.left = -60;
      mapCamera.right = 60;
      mapCamera.top = 40;
      mapCamera.bottom = -40;
      mapCamera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // 시작
    init();
  </script>
</body>
</html>